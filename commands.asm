; This is a big table of command-line commands.
;  16 bit x86 assembly language for NASM
;  Dr. Orion Lawlor, lawlor@alaska.edu, 2019-01-29 (Public Domain)


;  Each command has the format:
;    dq '<command line name>' (8 bytes maximum)
;    dd pointer to the command description (one-line help)
;    dd pointer to the command executable code 
command_list:
  
  dq 'ello'
  dd ello_str
  dd ello_code
  
  dq 'reg'
  dd reg_str
  dd reg_code
  
  
  dq 'mem'
  dd mem_str
  dd mem_code
  
  
; Interrupt demos
  dq 'int20'
  dd int_str
  dd int_code
  
  dq 'signals'
  dd signals_str
  dd signals_code
  
  dq 'sigill'
  dd sigill_str
  dd sigill_code
  
  dq 'divide0'
  dd divide0_str
  dd divide0_code
  
  dq 'hook'
  dd hooktimer_str
  dd hooktimer_code
  
  dq 'unhook'
  dd unhooktimer_str
  dd unhooktimer_code

; Command help
  dq 'help'
  dd help_str
  dd help_code
  
  dq '?'
  dd help_str
  dd help_code

end_command_table:


ello_str: db "Prints 'hello'.",0
ello_print: db "Hello there!",0
ello_code: 
  mov si,ello_print
  call printstrln
  ret

reg_str: db "Prints contents of registers.",0
reg_code:
  call debugdump
  ret

mem_str: db "Print contents of memory at a linear address.",0
mem_code:
  call readhex ; linear address
  mov esi,eax
  call println
  
  ; Dump one row of bytes:
  mov ecx,0
  .start_print:
    mov al, BYTE [esi+ecx] ; load byte from memory
    call printhex8
    mov al, ' '
    call printchar
    
    inc cx
    cmp cx,16
    jl .start_print
  
  call println
  ret

; ----------------- Interrupt magic
int_str: db "Demonstrates simple interrupt handling.",0
int_code:
  mov si, 4*0x20 ; interrupt 0x20, only used if you're running DOS
  mov WORD[si], my_int_code ; my code offset
  mov WORD[si+2], 0 ; my code segment
  
  mov al,'H'
  call printchar
  int 0x20 ; <- actually calls my interrupt handler
  call println
  
  ret

; My interrupt handler
my_int_code:
  pusha ; save all registers
  push ds
  mov ax,0 ; set our segment register
  mov ds,ax
  
  mov al,'I'
  call printchar
  
  pop ds
  popa ; restore all registers
  iret ; return from interrupt




signals_str: db "Load signal handlers to intercepts CPU crashes.",0
signals_code:
  ; http://stanislavs.org/helppc/int_table.html
  mov si,4*0x6 ; interrupt 0x6 is generated by the CPU on invalid opcode
  mov WORD[si],signal_bad_opcode
  mov WORD[si+2],0 ; segment
  
  mov si,4*0 ; interrupt 0 is generated by the CPU on divide by zero
  mov WORD[si],signal_divide0
  mov WORD[si+2], 0 ; segment
  
  ret

signal_bad_opcode:
  mov si,.str
  jmp machine_crash_hang
     .str: db "CPU detected an invalid opcode. (SIGILL)",0

signal_divide0:
  mov si,.str
  jmp machine_crash_hang
     .str: db "CPU tried to divide by 0. (SIGFPE)",0

; Input: si points to a human-readable debug message
; Output: never returns (program is toast, should probably have a soft reboot option)
machine_crash_hang:
  mov ax,0 ; we need our segment registers
  mov ds,ax
  mov es,ax
  call println
  call printstr
  call debugdump ; missing program counter tho
  
  mov si,.reset_str
  call printstrln
  call readchar
  call reboot
  .reset_str: db "Press any key to reboot",0


sigill_str: db "Run an illegal instruction, to test that signal handler.",0
sigill_code:
  mov al,'F'
  call printchar
  db 0xf0, 0x0f, 0xc7, 0xc8 ; see https://en.wikipedia.org/wiki/Pentium_F00F_bug
  mov al,'O'
  call printchar
  ret

divide0_str: db "Divide by zero, to test that signal handler.",0
divide0_code:
  mov al,'D'
  call printchar
  
  mov eax,123
  mov edx,0
  mov ecx,0
  idiv ecx ; <- divides by zero
  
  mov al,'0'
  call printchar
  ret


; Hooking the BIOS user interrupt 0x1C works fine.
; Somehow trying to hook the actual hardware interrupt 0x8 
;   locks up the BIOS on VirtualBox or physical Dell hardware (non-SeaBIOS).
hooktimer_str: db "Hooks the 0x1C timer interrupt.",0
hooktimer_code:
  cmp BYTE[timer_hooked],0
  jne nope
  
  ; We're hooking the timer interrupt 0x1C
  mov si,4*0x1C ; each interrupt timer entry is 4 bytes (offset and segment)
  
  cli
  mov eax,DWORD[si] ; save the old handler
  mov DWORD[timer_saved],eax
  
  mov WORD[si],timer_interrupt ; our code
  mov WORD[si+2],0 ; our segment
  mov BYTE[timer_hooked],1
  sti
  ret

; Bool flag preventing duplicate hooks
timer_hooked: db 0

timer_saved: ; saved copy of original interrupt handler
   dw 0,0

timer_counter: db 'A'

; This function is called directly from the hardware interrupt.
;   cs: our code segment
timer_interrupt:
  pusha ; save all registers (avoid trashing stuff during our interrupt work)
  push ds
  push es
  
  ; Do our own work: show random crud onscreen
  mov ax,0
  mov ds,ax ; data segment = our data (for timer_counter)
  
  mov ax,0xb800
  mov es,ax ; extra segment = onscreen (so you can see it)
  
  mov cl,BYTE[timer_counter]
  add cl,1
  cmp cl,'Z'
  jle .not_wrap
    mov cl,'A'
.not_wrap:
  mov BYTE[timer_counter],cl
  mov si,0
  mov BYTE[es:si], cl
  
  pop es
  pop ds
  popa
  iret



unhooktimer_str: db "Unhooks the timer interrupt.",0
unhooktimer_code:
  cmp BYTE[timer_hooked],1
  jne nope
  mov si,4*0x1C
  mov eax,DWORD[timer_saved] ; restore the old handler
  mov DWORD[si],eax
  mov BYTE[timer_hooked],0
  ret

nope_str: db "NOPE",0
nope:
  mov si,nope_str
  call printstrln
  ret

; ----------------- Command magic
; Walk the list of commands, and print the name and help text
help_str: db "Prints a list of possible commands.",0
help_code:
  mov edx,command_list
  .cmdloop:
    mov ecx,0
    .charloop:
      mov al,BYTE[edx+ecx]
      call printchar
      add cl,1
      cmp cl,8
      jl .charloop
    
    mov al,' '
    call printchar
    
    mov esi,DWORD[edx+8]
    call printstrln
    add edx,16 ; each command entry is 16 bytes
    cmp edx,end_command_table
    jl .cmdloop
  ret


; Find and run the commandline from cmdline_buf
cmdline_run:
  mov edx,command_list
  .cmdloop:
    mov ecx,0
    .charloop:
      mov al,BYTE[edx+ecx] ; char from command name
      
      cmp al,BYTE[cmdline_buf+ecx]
      jne .no_match
      
      cmp al,0
      je .good_match ; full match so far
      
      add ecx,1
      cmp ecx,8
      jl .charloop
    .good_match:
    
    mov eax,DWORD[edx+12]; pointer to command code
    call ax ;<- subtle: can't call eax, need segmented mode
    ret
    
    .no_match:
    add edx,16 ; each command entry is 16 bytes
    cmp edx,end_command_table
    jl .cmdloop
  mov si,cmd_not_found_str
  call printstrln
  ret

cmd_not_found_str:
  db "Unknown command.  Enter 'help' or '?' for a list.",0



; Buffer for command line being entered
cmdline_buf: times 10 dq 0
cmdline_buf_end:

cmd_prompt: db "O>$ ",0

; Read one command from the user into cmdline_buf
cmdline_read:
  mov si,cmd_prompt
  call printstr
  
  mov ecx,0 ; index into cmdline_buf
  cmdline_read_more:
    call readchar
    cmp al,13 ; hit newline
    je cmdline_read_done
    cmp cl,(cmdline_buf_end-cmdline_buf)
    je cmdline_read_done_toobig
    mov BYTE[cmdline_buf+ecx],al
    inc ecx
    jmp cmdline_read_more
  
  cmdline_read_done:
  mov BYTE[cmdline_buf+ecx],0 ; zero terminate string
  cmdline_read_done_toobig:
  call println

; echo the read-in command, for debugging
  mov al,'{'
  call printchar
  mov si,cmdline_buf 
  call printstr
  mov al,'}'
  call printchar
  call println
  ret


; Read one command from the user, and run it.
cmdline_run_cmd:
  call cmdline_read
  call cmdline_run
  ret



